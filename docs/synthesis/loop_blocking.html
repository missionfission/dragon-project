<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>loop_blocking API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>loop_blocking</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools

import numpy as np

# from . import DataCategoryEnum as de
# from . import MemHierEnum as me
# from . import Util


class NestedLoopDesc(object):
    &#34;&#34;&#34;
    Naive 3-nested loop (nifm, nofm, batch) description.
    &#34;&#34;&#34;

    def __init__(self, lifms, lofms, lbats, ugbuf, uregf, uacc, uops, utime):
        self.loopcnts = (lifms, lofms, lbats)
        self.usize = (ugbuf, uregf)
        self.uacc = uacc
        self.uops = uops
        self.utime = utime

        for usz in self.usize:
            assert len(usz) == de.NUM

        assert len(self.uacc) == me.NUM
        for ua in range(me.NUM):
            assert len(self.uacc[ua]) == de.NUM

    def loopcnt_ifm(self):
        &#34;&#34;&#34; Get nifm loop count. &#34;&#34;&#34;
        return self.loopcnts[0]

    def loopcnt_ofm(self):
        &#34;&#34;&#34; Get nofm loop count. &#34;&#34;&#34;
        return self.loopcnts[1]

    def loopcnt_bat(self):
        &#34;&#34;&#34; Get batch loop count. &#34;&#34;&#34;
        return self.loopcnts[2]

    def usize_gbuf(self, dce=None):
        &#34;&#34;&#34;
        Get occupied gbuf size of one innermost loop by data category `dce`.

        If None, return entire list of occupied gbuf sizes for all categories.
        &#34;&#34;&#34;
        return self.usize[0][dce] if dce is not None else self.usize[0]

    def usize_regf(self, dce=None):
        &#34;&#34;&#34;
        Get occupied regf size of one innermost loop by data category `dce`.

        If None, return entire list of occupied regf sizes for all categories.
        &#34;&#34;&#34;
        return self.usize[1][dce] if dce is not None else self.usize[1]

    def unit_access(self, mhe=None, dce=None):
        &#34;&#34;&#34;
        Get number of accesses of one innermost loop by memory hierarchy `mhe`
        of data category `dce`.

        If None, return entire list of accesses for the entire hierarchy.
        &#34;&#34;&#34;
        try:
            return self.uacc[mhe][dce]
        except (TypeError, IndexError):
            try:
                return self.uacc[mhe]
            except (TypeError, IndexError):
                return self.uacc

    def unit_num_ops(self):
        &#34;&#34;&#34; Get number of ops of one innermost loop. &#34;&#34;&#34;
        return self.uops

    def unit_time(self):
        &#34;&#34;&#34; Get execution time of one innermost loop. &#34;&#34;&#34;
        return self.utime

    def __str__(self):
        &#34;&#34;&#34; Print. &#34;&#34;&#34;
        str_ = &#34;loopcnts={}&#34;.format(self.loopcnts)
        str_ += &#34;, usize={}&#34;.format(self.usize)
        str_ += &#34;, uacc={}&#34;.format(self.uacc)
        str_ += &#34;, uops={}&#34;.format(self.uops)
        str_ += &#34;, utime={}&#34;.format(self.utime)
        return str_


def cost_loopblocking_gbuf_regf(
    tifm, tofm, tbat, orders, resource, cost, nested_loop_desc, options
):
    &#34;&#34;&#34;
    Given 2-tiled (length-3) `ti`, `to`, and `tb` for ifm, ofm and batching,
    and the loop `orders` of each tiling level, return the cost after loop
    blocking and the blocking parameters as a tuple (cost_loop, dict_loop).

    `orders` should be indexed by MemHierEnum, and only GBUF and REGF entries
    are valid. Each entry is a ordered tuple of IFM and OFM. Smaller index
    corresponds to inner loop. Batching loop order should never in between IFM
    and OFM, so we can enforce it to the outermost level for all memory
    hierarchy (innermost can be viewed as the outermost of the inner next
    hierarchy). So nested loop order is: tb[0], ti[0]/to[0], tb[1],
    ti[1]/to[1], tb[2], ti[2]/to[2]

    &#34;&#34;&#34;

    ## Input check.

    # Translate tx to np.ndarray, for better perf.
    ti = np.array(tifm)
    to = np.array(tofm)
    tb = np.array(tbat)

    tip = np.prod(ti)
    top = np.prod(to)
    tbp = np.prod(tb)

    # Check lengths and values.
    if ti.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for ti.&#34;)
    if to.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for to.&#34;)
    if tb.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for tb.&#34;)

    class BL(object):  # pylint: disable=too-few-public-methods
        &#34;&#34;&#34;
        Blocking-level enum. Only used locally.
        &#34;&#34;&#34;

        GBUF = 0
        REGF = 1
        NUM = 2

    try:
        if tip &lt; nested_loop_desc.loopcnt_ifm():
            raise ValueError(&#34;LoopBlocking: invalid blocking for ifm: {}&#34;.format(ti))
        if top &lt; nested_loop_desc.loopcnt_ofm():
            raise ValueError(&#34;LoopBlocking: invalid blocking for ofm: {}&#34;.format(to))
        if tbp &lt; nested_loop_desc.loopcnt_bat():
            raise ValueError(&#34;LoopBlocking: invalid blocking for bat: {}&#34;.format(tb))
    except Exception as e:
        return (float(&#34;inf&#34;), None)

    ## Buffer data sizes in unit counts.

    cnt_units = [None for _ in range(BL.NUM)]
    for bl in range(BL.NUM):
        cnt_units[bl] = [0] * de.NUM
        cnt_units[bl][de.FIL] = np.prod(ti[bl + 1 :]) * np.prod(to[bl + 1 :])
        cnt_units[bl][de.IFM] = np.prod(ti[bl + 1 :]) * np.prod(tb[bl + 1 :])
        cnt_units[bl][de.OFM] = np.prod(to[bl + 1 :]) * np.prod(tb[bl + 1 :])

    ## Num ops, time, etc.

    lcnt_total = tip * top * tbp

    ops_total = nested_loop_desc.unit_num_ops() * lcnt_total

    time_total = nested_loop_desc.unit_time() * lcnt_total

    ## Basic size and reuse.

    assert BL.GBUF == 0
    assert BL.REGF == 1
    unit_size = [
        [x for x in nested_loop_desc.usize_gbuf()],
        [x for x in nested_loop_desc.usize_regf()],
    ]
    reuse = [None for _ in range(BL.NUM)]
    for bl in range(BL.NUM):
        reuse[bl] = [0] * de.NUM
        reuse[bl][de.FIL] = np.prod(tb[bl + 1 :])
        reuse[bl][de.IFM] = np.prod(to[bl + 1 :])
        reuse[bl][de.OFM] = np.prod(ti[bl + 1 :])

    ## Adjusted size and reuse based on loop orders, bypass, etc..

    size = [None] * BL.NUM

    def adjust_reuse(reuse_, bl_cur, order_cur, bls_outer, orders_outer):
        &#34;&#34;&#34;
        Adjust the data reuse based on special loop structures.

        reuse_ is the reuse numbers for a specific level, e.g., reuse[BL.REGF].

        This function is recursive as we need to look at the outer levels.
        &#34;&#34;&#34;
        if ti[bl_cur] != 1 and to[bl_cur] != 1:
            if order_cur.index(de.IFM) &lt; order_cur.index(de.OFM):
                # Loop ifm inside loop ofm.
                # ofm also reused across current-level ifms.
                reuse_[de.OFM] *= ti[bl_cur]
            else:
                # Loop ifm outside loop ofm.
                # ifm also reused across current-level ofms.
                reuse_[de.IFM] *= to[bl_cur]
        elif ti[bl_cur] == 1 and to[bl_cur] != 1:
            # Current level does not change ifm, so ifm reuses ofms.
            reuse_[de.IFM] *= to[bl_cur]
        elif ti[bl_cur] != 1 and to[bl_cur] == 1:
            # Current level does not change ofm, so ofm reuses ifms.
            reuse_[de.OFM] *= ti[bl_cur]
        else:
            assert ti[bl_cur] == 1 and to[bl_cur] == 1
            # Current level loop counts are both 1 for ifms and ofms.
            # Effectively this level does not change the buffered data in the
            # inner level.
            # See the outer level.
            assert len(bls_outer) == len(orders_outer)
            if len(bls_outer) &gt; 0:
                adjust_reuse(
                    reuse_,
                    bls_outer[0],
                    orders_outer[0],
                    bls_outer[1:],
                    orders_outer[1:],
                )

    # regf.
    adjust_reuse(reuse[BL.REGF], BL.REGF, orders[me.REGF], [BL.GBUF], [orders[me.GBUF]])

    size[BL.REGF] = [
        np.prod(tuple_) for tuple_ in zip(unit_size[BL.REGF], cnt_units[BL.REGF])
    ]
    if sum(size[BL.REGF]) &gt; resource.size_regf:
        return (float(&#34;inf&#34;), None)

    # gbuf.
    adjust_reuse(reuse[BL.GBUF], BL.GBUF, orders[me.GBUF], [], [])

    stored_in_gbuf = [1] * de.NUM
    # Only store in gbuf if having reuse.
    for deum in range(de.NUM):
        stored_in_gbuf[deum] = (
            1
            if not options.allow_gbuf_bypass[deum]
            or reuse[BL.GBUF][deum] &gt; reuse[BL.REGF][deum]
            else 0
        )

    size[BL.GBUF] = [
        np.prod(tuple_)
        for tuple_ in zip(unit_size[BL.GBUF], cnt_units[BL.GBUF], stored_in_gbuf)
    ]
    if sum(size[BL.GBUF]) &gt; resource.size_gbuf:
        return (float(&#34;inf&#34;), None)

    ## Access.

    access = [0] * me.NUM

    access[me.REGF] = [v * lcnt_total for v in nested_loop_desc.unit_access(me.REGF)]

    access[me.ITCN] = [
        v * lcnt_total // r
        for v, r in zip(nested_loop_desc.unit_access(me.ITCN), reuse[BL.REGF])
    ]

    access[me.GBUF] = [
        v * lcnt_total // r * s
        for v, r, s in zip(
            nested_loop_desc.unit_access(me.GBUF), reuse[BL.REGF], stored_in_gbuf
        )
    ]

    access[me.DRAM] = [
        v * lcnt_total // r
        for v, r in zip(nested_loop_desc.unit_access(me.DRAM), reuse[BL.GBUF])
    ]

    ## Cost.

    access_total = [sum(a) for a in access]
    cost_loop = (
        np.dot(cost.memhier(), access_total)
        + ops_total * cost.macop()
        + time_total * cost.unit_static()
    )

    dict_loop = {
        &#34;ops&#34;: ops_total,
        &#34;time&#34;: time_total,
        &#34;access&#34;: access,
        &#34;size&#34;: size,
        &#34;unit_size&#34;: unit_size,
        &#34;ti&#34;: tuple(ti),
        &#34;to&#34;: tuple(to),
        &#34;tb&#34;: tuple(tb),
        &#34;orders&#34;: orders,
    }

    return (cost_loop, dict_loop)


def gen_loopblocking_gbuf_regf(
    resource, cost, nested_loop_desc, options, layer_lb=None
):
    &#34;&#34;&#34;
    Generator for loop blocking schemes.
    &#34;&#34;&#34;
    for ti, to, tb, orders in itertools.product(
        Util.factorize(nested_loop_desc.loopcnt_ifm(), 3),
        Util.factorize(nested_loop_desc.loopcnt_ofm(), 3),
        Util.factorize(nested_loop_desc.loopcnt_bat(), 3),
        itertools.product(
            [None],
            itertools.permutations((de.IFM, de.OFM)),
            [None],
            itertools.permutations((de.IFM, de.OFM)),
        ),
    ):

        if layer_lb is not None:
            if layer_lb[&#34;ti&#34;] is not None and ti != layer_lb[&#34;ti&#34;]:
                continue
            if layer_lb[&#34;to&#34;] is not None and to != layer_lb[&#34;to&#34;]:
                continue
            if layer_lb[&#34;tb&#34;] is not None and tb != layer_lb[&#34;tb&#34;]:
                continue
            if layer_lb[&#34;orders&#34;] is not None and orders != layer_lb[&#34;orders&#34;]:
                continue

        yield cost_loopblocking_gbuf_regf(
            ti,
            to,
            tb,
            orders,
            resource=resource,
            cost=cost,
            nested_loop_desc=nested_loop_desc,
            options=options,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="loop_blocking.cost_loopblocking_gbuf_regf"><code class="name flex">
<span>def <span class="ident">cost_loopblocking_gbuf_regf</span></span>(<span>tifm, tofm, tbat, orders, resource, cost, nested_loop_desc, options)</span>
</code></dt>
<dd>
<div class="desc"><p>Given 2-tiled (length-3) <code>ti</code>, <code>to</code>, and <code>tb</code> for ifm, ofm and batching,
and the loop <code>orders</code> of each tiling level, return the cost after loop
blocking and the blocking parameters as a tuple (cost_loop, dict_loop).</p>
<p><code>orders</code> should be indexed by MemHierEnum, and only GBUF and REGF entries
are valid. Each entry is a ordered tuple of IFM and OFM. Smaller index
corresponds to inner loop. Batching loop order should never in between IFM
and OFM, so we can enforce it to the outermost level for all memory
hierarchy (innermost can be viewed as the outermost of the inner next
hierarchy). So nested loop order is: tb[0], ti[0]/to[0], tb[1],
ti[1]/to[1], tb[2], ti[2]/to[2]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cost_loopblocking_gbuf_regf(
    tifm, tofm, tbat, orders, resource, cost, nested_loop_desc, options
):
    &#34;&#34;&#34;
    Given 2-tiled (length-3) `ti`, `to`, and `tb` for ifm, ofm and batching,
    and the loop `orders` of each tiling level, return the cost after loop
    blocking and the blocking parameters as a tuple (cost_loop, dict_loop).

    `orders` should be indexed by MemHierEnum, and only GBUF and REGF entries
    are valid. Each entry is a ordered tuple of IFM and OFM. Smaller index
    corresponds to inner loop. Batching loop order should never in between IFM
    and OFM, so we can enforce it to the outermost level for all memory
    hierarchy (innermost can be viewed as the outermost of the inner next
    hierarchy). So nested loop order is: tb[0], ti[0]/to[0], tb[1],
    ti[1]/to[1], tb[2], ti[2]/to[2]

    &#34;&#34;&#34;

    ## Input check.

    # Translate tx to np.ndarray, for better perf.
    ti = np.array(tifm)
    to = np.array(tofm)
    tb = np.array(tbat)

    tip = np.prod(ti)
    top = np.prod(to)
    tbp = np.prod(tb)

    # Check lengths and values.
    if ti.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for ti.&#34;)
    if to.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for to.&#34;)
    if tb.size != 3:
        raise ValueError(&#34;LoopBlocking: wrong length for tb.&#34;)

    class BL(object):  # pylint: disable=too-few-public-methods
        &#34;&#34;&#34;
        Blocking-level enum. Only used locally.
        &#34;&#34;&#34;

        GBUF = 0
        REGF = 1
        NUM = 2

    try:
        if tip &lt; nested_loop_desc.loopcnt_ifm():
            raise ValueError(&#34;LoopBlocking: invalid blocking for ifm: {}&#34;.format(ti))
        if top &lt; nested_loop_desc.loopcnt_ofm():
            raise ValueError(&#34;LoopBlocking: invalid blocking for ofm: {}&#34;.format(to))
        if tbp &lt; nested_loop_desc.loopcnt_bat():
            raise ValueError(&#34;LoopBlocking: invalid blocking for bat: {}&#34;.format(tb))
    except Exception as e:
        return (float(&#34;inf&#34;), None)

    ## Buffer data sizes in unit counts.

    cnt_units = [None for _ in range(BL.NUM)]
    for bl in range(BL.NUM):
        cnt_units[bl] = [0] * de.NUM
        cnt_units[bl][de.FIL] = np.prod(ti[bl + 1 :]) * np.prod(to[bl + 1 :])
        cnt_units[bl][de.IFM] = np.prod(ti[bl + 1 :]) * np.prod(tb[bl + 1 :])
        cnt_units[bl][de.OFM] = np.prod(to[bl + 1 :]) * np.prod(tb[bl + 1 :])

    ## Num ops, time, etc.

    lcnt_total = tip * top * tbp

    ops_total = nested_loop_desc.unit_num_ops() * lcnt_total

    time_total = nested_loop_desc.unit_time() * lcnt_total

    ## Basic size and reuse.

    assert BL.GBUF == 0
    assert BL.REGF == 1
    unit_size = [
        [x for x in nested_loop_desc.usize_gbuf()],
        [x for x in nested_loop_desc.usize_regf()],
    ]
    reuse = [None for _ in range(BL.NUM)]
    for bl in range(BL.NUM):
        reuse[bl] = [0] * de.NUM
        reuse[bl][de.FIL] = np.prod(tb[bl + 1 :])
        reuse[bl][de.IFM] = np.prod(to[bl + 1 :])
        reuse[bl][de.OFM] = np.prod(ti[bl + 1 :])

    ## Adjusted size and reuse based on loop orders, bypass, etc..

    size = [None] * BL.NUM

    def adjust_reuse(reuse_, bl_cur, order_cur, bls_outer, orders_outer):
        &#34;&#34;&#34;
        Adjust the data reuse based on special loop structures.

        reuse_ is the reuse numbers for a specific level, e.g., reuse[BL.REGF].

        This function is recursive as we need to look at the outer levels.
        &#34;&#34;&#34;
        if ti[bl_cur] != 1 and to[bl_cur] != 1:
            if order_cur.index(de.IFM) &lt; order_cur.index(de.OFM):
                # Loop ifm inside loop ofm.
                # ofm also reused across current-level ifms.
                reuse_[de.OFM] *= ti[bl_cur]
            else:
                # Loop ifm outside loop ofm.
                # ifm also reused across current-level ofms.
                reuse_[de.IFM] *= to[bl_cur]
        elif ti[bl_cur] == 1 and to[bl_cur] != 1:
            # Current level does not change ifm, so ifm reuses ofms.
            reuse_[de.IFM] *= to[bl_cur]
        elif ti[bl_cur] != 1 and to[bl_cur] == 1:
            # Current level does not change ofm, so ofm reuses ifms.
            reuse_[de.OFM] *= ti[bl_cur]
        else:
            assert ti[bl_cur] == 1 and to[bl_cur] == 1
            # Current level loop counts are both 1 for ifms and ofms.
            # Effectively this level does not change the buffered data in the
            # inner level.
            # See the outer level.
            assert len(bls_outer) == len(orders_outer)
            if len(bls_outer) &gt; 0:
                adjust_reuse(
                    reuse_,
                    bls_outer[0],
                    orders_outer[0],
                    bls_outer[1:],
                    orders_outer[1:],
                )

    # regf.
    adjust_reuse(reuse[BL.REGF], BL.REGF, orders[me.REGF], [BL.GBUF], [orders[me.GBUF]])

    size[BL.REGF] = [
        np.prod(tuple_) for tuple_ in zip(unit_size[BL.REGF], cnt_units[BL.REGF])
    ]
    if sum(size[BL.REGF]) &gt; resource.size_regf:
        return (float(&#34;inf&#34;), None)

    # gbuf.
    adjust_reuse(reuse[BL.GBUF], BL.GBUF, orders[me.GBUF], [], [])

    stored_in_gbuf = [1] * de.NUM
    # Only store in gbuf if having reuse.
    for deum in range(de.NUM):
        stored_in_gbuf[deum] = (
            1
            if not options.allow_gbuf_bypass[deum]
            or reuse[BL.GBUF][deum] &gt; reuse[BL.REGF][deum]
            else 0
        )

    size[BL.GBUF] = [
        np.prod(tuple_)
        for tuple_ in zip(unit_size[BL.GBUF], cnt_units[BL.GBUF], stored_in_gbuf)
    ]
    if sum(size[BL.GBUF]) &gt; resource.size_gbuf:
        return (float(&#34;inf&#34;), None)

    ## Access.

    access = [0] * me.NUM

    access[me.REGF] = [v * lcnt_total for v in nested_loop_desc.unit_access(me.REGF)]

    access[me.ITCN] = [
        v * lcnt_total // r
        for v, r in zip(nested_loop_desc.unit_access(me.ITCN), reuse[BL.REGF])
    ]

    access[me.GBUF] = [
        v * lcnt_total // r * s
        for v, r, s in zip(
            nested_loop_desc.unit_access(me.GBUF), reuse[BL.REGF], stored_in_gbuf
        )
    ]

    access[me.DRAM] = [
        v * lcnt_total // r
        for v, r in zip(nested_loop_desc.unit_access(me.DRAM), reuse[BL.GBUF])
    ]

    ## Cost.

    access_total = [sum(a) for a in access]
    cost_loop = (
        np.dot(cost.memhier(), access_total)
        + ops_total * cost.macop()
        + time_total * cost.unit_static()
    )

    dict_loop = {
        &#34;ops&#34;: ops_total,
        &#34;time&#34;: time_total,
        &#34;access&#34;: access,
        &#34;size&#34;: size,
        &#34;unit_size&#34;: unit_size,
        &#34;ti&#34;: tuple(ti),
        &#34;to&#34;: tuple(to),
        &#34;tb&#34;: tuple(tb),
        &#34;orders&#34;: orders,
    }

    return (cost_loop, dict_loop)</code></pre>
</details>
</dd>
<dt id="loop_blocking.gen_loopblocking_gbuf_regf"><code class="name flex">
<span>def <span class="ident">gen_loopblocking_gbuf_regf</span></span>(<span>resource, cost, nested_loop_desc, options, layer_lb=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generator for loop blocking schemes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_loopblocking_gbuf_regf(
    resource, cost, nested_loop_desc, options, layer_lb=None
):
    &#34;&#34;&#34;
    Generator for loop blocking schemes.
    &#34;&#34;&#34;
    for ti, to, tb, orders in itertools.product(
        Util.factorize(nested_loop_desc.loopcnt_ifm(), 3),
        Util.factorize(nested_loop_desc.loopcnt_ofm(), 3),
        Util.factorize(nested_loop_desc.loopcnt_bat(), 3),
        itertools.product(
            [None],
            itertools.permutations((de.IFM, de.OFM)),
            [None],
            itertools.permutations((de.IFM, de.OFM)),
        ),
    ):

        if layer_lb is not None:
            if layer_lb[&#34;ti&#34;] is not None and ti != layer_lb[&#34;ti&#34;]:
                continue
            if layer_lb[&#34;to&#34;] is not None and to != layer_lb[&#34;to&#34;]:
                continue
            if layer_lb[&#34;tb&#34;] is not None and tb != layer_lb[&#34;tb&#34;]:
                continue
            if layer_lb[&#34;orders&#34;] is not None and orders != layer_lb[&#34;orders&#34;]:
                continue

        yield cost_loopblocking_gbuf_regf(
            ti,
            to,
            tb,
            orders,
            resource=resource,
            cost=cost,
            nested_loop_desc=nested_loop_desc,
            options=options,
        )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="loop_blocking.NestedLoopDesc"><code class="flex name class">
<span>class <span class="ident">NestedLoopDesc</span></span>
<span>(</span><span>lifms, lofms, lbats, ugbuf, uregf, uacc, uops, utime)</span>
</code></dt>
<dd>
<div class="desc"><p>Naive 3-nested loop (nifm, nofm, batch) description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NestedLoopDesc(object):
    &#34;&#34;&#34;
    Naive 3-nested loop (nifm, nofm, batch) description.
    &#34;&#34;&#34;

    def __init__(self, lifms, lofms, lbats, ugbuf, uregf, uacc, uops, utime):
        self.loopcnts = (lifms, lofms, lbats)
        self.usize = (ugbuf, uregf)
        self.uacc = uacc
        self.uops = uops
        self.utime = utime

        for usz in self.usize:
            assert len(usz) == de.NUM

        assert len(self.uacc) == me.NUM
        for ua in range(me.NUM):
            assert len(self.uacc[ua]) == de.NUM

    def loopcnt_ifm(self):
        &#34;&#34;&#34; Get nifm loop count. &#34;&#34;&#34;
        return self.loopcnts[0]

    def loopcnt_ofm(self):
        &#34;&#34;&#34; Get nofm loop count. &#34;&#34;&#34;
        return self.loopcnts[1]

    def loopcnt_bat(self):
        &#34;&#34;&#34; Get batch loop count. &#34;&#34;&#34;
        return self.loopcnts[2]

    def usize_gbuf(self, dce=None):
        &#34;&#34;&#34;
        Get occupied gbuf size of one innermost loop by data category `dce`.

        If None, return entire list of occupied gbuf sizes for all categories.
        &#34;&#34;&#34;
        return self.usize[0][dce] if dce is not None else self.usize[0]

    def usize_regf(self, dce=None):
        &#34;&#34;&#34;
        Get occupied regf size of one innermost loop by data category `dce`.

        If None, return entire list of occupied regf sizes for all categories.
        &#34;&#34;&#34;
        return self.usize[1][dce] if dce is not None else self.usize[1]

    def unit_access(self, mhe=None, dce=None):
        &#34;&#34;&#34;
        Get number of accesses of one innermost loop by memory hierarchy `mhe`
        of data category `dce`.

        If None, return entire list of accesses for the entire hierarchy.
        &#34;&#34;&#34;
        try:
            return self.uacc[mhe][dce]
        except (TypeError, IndexError):
            try:
                return self.uacc[mhe]
            except (TypeError, IndexError):
                return self.uacc

    def unit_num_ops(self):
        &#34;&#34;&#34; Get number of ops of one innermost loop. &#34;&#34;&#34;
        return self.uops

    def unit_time(self):
        &#34;&#34;&#34; Get execution time of one innermost loop. &#34;&#34;&#34;
        return self.utime

    def __str__(self):
        &#34;&#34;&#34; Print. &#34;&#34;&#34;
        str_ = &#34;loopcnts={}&#34;.format(self.loopcnts)
        str_ += &#34;, usize={}&#34;.format(self.usize)
        str_ += &#34;, uacc={}&#34;.format(self.uacc)
        str_ += &#34;, uops={}&#34;.format(self.uops)
        str_ += &#34;, utime={}&#34;.format(self.utime)
        return str_</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="loop_blocking.NestedLoopDesc.loopcnt_bat"><code class="name flex">
<span>def <span class="ident">loopcnt_bat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get batch loop count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loopcnt_bat(self):
    &#34;&#34;&#34; Get batch loop count. &#34;&#34;&#34;
    return self.loopcnts[2]</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.loopcnt_ifm"><code class="name flex">
<span>def <span class="ident">loopcnt_ifm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get nifm loop count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loopcnt_ifm(self):
    &#34;&#34;&#34; Get nifm loop count. &#34;&#34;&#34;
    return self.loopcnts[0]</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.loopcnt_ofm"><code class="name flex">
<span>def <span class="ident">loopcnt_ofm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get nofm loop count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loopcnt_ofm(self):
    &#34;&#34;&#34; Get nofm loop count. &#34;&#34;&#34;
    return self.loopcnts[1]</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.unit_access"><code class="name flex">
<span>def <span class="ident">unit_access</span></span>(<span>self, mhe=None, dce=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get number of accesses of one innermost loop by memory hierarchy <code>mhe</code>
of data category <code>dce</code>.</p>
<p>If None, return entire list of accesses for the entire hierarchy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_access(self, mhe=None, dce=None):
    &#34;&#34;&#34;
    Get number of accesses of one innermost loop by memory hierarchy `mhe`
    of data category `dce`.

    If None, return entire list of accesses for the entire hierarchy.
    &#34;&#34;&#34;
    try:
        return self.uacc[mhe][dce]
    except (TypeError, IndexError):
        try:
            return self.uacc[mhe]
        except (TypeError, IndexError):
            return self.uacc</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.unit_num_ops"><code class="name flex">
<span>def <span class="ident">unit_num_ops</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get number of ops of one innermost loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_num_ops(self):
    &#34;&#34;&#34; Get number of ops of one innermost loop. &#34;&#34;&#34;
    return self.uops</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.unit_time"><code class="name flex">
<span>def <span class="ident">unit_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get execution time of one innermost loop.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_time(self):
    &#34;&#34;&#34; Get execution time of one innermost loop. &#34;&#34;&#34;
    return self.utime</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.usize_gbuf"><code class="name flex">
<span>def <span class="ident">usize_gbuf</span></span>(<span>self, dce=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get occupied gbuf size of one innermost loop by data category <code>dce</code>.</p>
<p>If None, return entire list of occupied gbuf sizes for all categories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usize_gbuf(self, dce=None):
    &#34;&#34;&#34;
    Get occupied gbuf size of one innermost loop by data category `dce`.

    If None, return entire list of occupied gbuf sizes for all categories.
    &#34;&#34;&#34;
    return self.usize[0][dce] if dce is not None else self.usize[0]</code></pre>
</details>
</dd>
<dt id="loop_blocking.NestedLoopDesc.usize_regf"><code class="name flex">
<span>def <span class="ident">usize_regf</span></span>(<span>self, dce=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get occupied regf size of one innermost loop by data category <code>dce</code>.</p>
<p>If None, return entire list of occupied regf sizes for all categories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usize_regf(self, dce=None):
    &#34;&#34;&#34;
    Get occupied regf size of one innermost loop by data category `dce`.

    If None, return entire list of occupied regf sizes for all categories.
    &#34;&#34;&#34;
    return self.usize[1][dce] if dce is not None else self.usize[1]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="loop_blocking.cost_loopblocking_gbuf_regf" href="#loop_blocking.cost_loopblocking_gbuf_regf">cost_loopblocking_gbuf_regf</a></code></li>
<li><code><a title="loop_blocking.gen_loopblocking_gbuf_regf" href="#loop_blocking.gen_loopblocking_gbuf_regf">gen_loopblocking_gbuf_regf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="loop_blocking.NestedLoopDesc" href="#loop_blocking.NestedLoopDesc">NestedLoopDesc</a></code></h4>
<ul class="two-column">
<li><code><a title="loop_blocking.NestedLoopDesc.loopcnt_bat" href="#loop_blocking.NestedLoopDesc.loopcnt_bat">loopcnt_bat</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.loopcnt_ifm" href="#loop_blocking.NestedLoopDesc.loopcnt_ifm">loopcnt_ifm</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.loopcnt_ofm" href="#loop_blocking.NestedLoopDesc.loopcnt_ofm">loopcnt_ofm</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.unit_access" href="#loop_blocking.NestedLoopDesc.unit_access">unit_access</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.unit_num_ops" href="#loop_blocking.NestedLoopDesc.unit_num_ops">unit_num_ops</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.unit_time" href="#loop_blocking.NestedLoopDesc.unit_time">unit_time</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.usize_gbuf" href="#loop_blocking.NestedLoopDesc.usize_gbuf">usize_gbuf</a></code></li>
<li><code><a title="loop_blocking.NestedLoopDesc.usize_regf" href="#loop_blocking.NestedLoopDesc.usize_regf">usize_regf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>