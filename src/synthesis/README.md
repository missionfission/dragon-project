# High-Level Synthesis (HLS) Implementation

This directory contains the implementation of a High-Level Synthesis (HLS) tool for hardware design space exploration and validation.

## Overview

The HLS tool takes a Python function as input and generates hardware metrics such as:
- Cycle count
- Power consumption
- Hardware resource allocation
- Memory configurations

## Key Components

### Data Flow Graph (DFG)

The HLS tool builds a Data Flow Graph (DFG) from the AST representation of the input function. The DFG captures:
- Compute operations
- Memory operations
- Control flow
- Data dependencies

### Scheduling

The HLS tool uses a list scheduling algorithm to schedule operations on hardware resources. The scheduler:
- Calculates ASAP (As Soon As Possible) schedule
- Respects data dependencies
- Allocates resources based on constraints
- Handles resource conflicts

### Resource Allocation

The HLS tool allocates hardware resources based on the scheduled operations. The allocator:
- Counts required resources by type
- Allocates minimum resources needed
- Calculates power consumption

### Power Calculation

The HLS tool calculates power consumption based on the allocated resources. The power calculation:
- Considers dynamic and leakage power
- Scales power based on technology node
- Accounts for memory and functional unit power

## Recent Improvements

1. **Enhanced AST Analysis**: Improved the analysis of AST nodes to better capture operations in complex functions.

2. **Data Dependency Tracking**: Added tracking of data dependencies between operations to ensure correct scheduling.

3. **Algorithm-Specific Optimizations**: Added specialized handling for different algorithm types:
   - AES encryption
   - Matrix multiplication
   - FIR filters

4. **Floating-Point Handling**: Fixed issues with floating-point latency values in scheduling and resource allocation.

5. **Resource Constraints**: Added support for resource constraints based on design space exploration parameters.

6. **Technology Node Scaling**: Added support for scaling latency and power values based on technology node.

7. **Verbose Output**: Added detailed analysis output for debugging and validation.

## Usage

```python
from ir.cfg.staticfg import CFGBuilder
from synthesis.hls import parse_graph

# Create CFG builder
cfg_builder = CFGBuilder(tech_node='45nm')

# Build CFG from source code
src_code = """
def example_function(a, b):
    c = a + b
    return c
"""
cfg = cfg_builder.build_from_src("example_function", src_code)

# Parse graph and get hardware metrics
cycles, hw_allocated, memory_cfgs = parse_graph(
    cfg,
    dse_given=True,
    dse_input={"cycle_time": 2, "unrolling": 2},
    given_bandwidth=1000000,
    tech_node='45nm'
)

# Print results
print(f"Cycles: {cycles}")
print(f"Hardware allocation: {hw_allocated}")
print(f"Memory configurations: {memory_cfgs}")
```

## Validation

The HLS tool includes validation tests for different benchmarks:
- AES encryption
- Matrix multiplication
- FIR filters

These tests compare the hardware metrics generated by the HLS tool with theoretical calculations to ensure accuracy.

## Future Work

1. **Loop Transformations**: Add support for loop unrolling, loop fusion, and loop tiling.

2. **Memory Optimizations**: Add support for memory partitioning and memory banking.

3. **Pipeline Optimization**: Add support for pipeline optimization to improve throughput.

4. **Automatic DSE**: Add support for automatic design space exploration to find optimal hardware configurations.

5. **Integration with RTL Generation**: Add support for generating RTL code from the scheduled operations. 